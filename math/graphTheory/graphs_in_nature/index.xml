<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Graphs in nature on Vishvas&#39;s notes</title>
    <link>https://vishvAsa.github.io/notes/math/graphTheory/graphs_in_nature/</link>
    <description>Recent content in Graphs in nature on Vishvas&#39;s notes</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <atom:link href="https://vishvAsa.github.io/notes/math/graphTheory/graphs_in_nature/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Find dense subgraphs</title>
      <link>https://vishvAsa.github.io/notes/math/graphTheory/graphs_in_nature/find_dense_subgraphs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://vishvAsa.github.io/notes/math/graphTheory/graphs_in_nature/find_dense_subgraphs/</guid>
      <description>&lt;h2 id=&#34;a-b-cluster-c&#34;&gt;(a, b) cluster C&lt;/h2&gt;&#xA;&lt;p&gt;(Tarjan etal.) E(v, C): edges between v and C. External sparsity vs internal density of edges: \(\forall v \in C: |E(v, C)|\geq b|C|\), \(\forall u \notin C: |E(u, C)|\leq a|C|\). Cliques are (a, 1) clusters.&lt;/p&gt;&#xA;&lt;p&gt;Bound on cluster overlap known. For certain (a, b) it is possible for one cluster to be contained in another, but not if size of largest : smallest cluster size \(\leq \frac{1-a}{1-b}\). \(b&amp;gt;1/2\) ensures cluster connectedness: condition may be too strong in practice.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Generative models</title>
      <link>https://vishvAsa.github.io/notes/math/graphTheory/graphs_in_nature/generative_models/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://vishvAsa.github.io/notes/math/graphTheory/graphs_in_nature/generative_models/</guid>
      <description>&lt;h2 id=&#34;applications&#34;&gt;Applications&lt;/h2&gt;&#xA;&lt;p&gt;Finding patterns and abnormalities in real world networks.&lt;/p&gt;&#xA;&lt;p&gt;Making either fine or coarse grained hypotheses of graph formation process.&lt;/p&gt;&#xA;&lt;h3 id=&#34;making-extrapolations&#34;&gt;Making Extrapolations&lt;/h3&gt;&#xA;&lt;p&gt;What will G look like 10 months later?&lt;/p&gt;&#xA;&lt;p&gt;So, algorithmic benefits of the model important: How easy is it to calculate paths? Eg: A may be queries, C may be retrieved documents, maybe we want to find the closest commercial/ advertisement-carrying queries, so want to find shortest path to commercial query in the network of queries.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Link prediction</title>
      <link>https://vishvAsa.github.io/notes/math/graphTheory/graphs_in_nature/link_prediction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://vishvAsa.github.io/notes/math/graphTheory/graphs_in_nature/link_prediction/</guid>
      <description>&lt;p&gt;Graph G = (V, E). Every edge has this label: t(e): The time during which interaction represented by e took place. Given \(G[t_{0}, t_{0}&amp;rsquo;]\) (training interval), output a list of edges not presented in it, but present in \(G[t_{1}, t_{1}&amp;rsquo;]\) (testing interval). Maybe want to output top n most likely-to-appear edges.&lt;/p&gt;&#xA;&lt;h2 id=&#34;motivation&#34;&gt;Motivation&lt;/h2&gt;&#xA;&lt;p&gt;Security. Improving organizational efficiency by going beyond official hierarchy. Inferring missing links from observed network.&lt;/p&gt;&#xA;&lt;h2 id=&#34;observations-about-link-prediction&#34;&gt;Observations about link prediction&lt;/h2&gt;&#xA;&lt;p&gt;Small world problem: tenuous short links exist between otherwise unrelated nodes: noise wrt to the link prediction problem.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Node partitioning</title>
      <link>https://vishvAsa.github.io/notes/math/graphTheory/graphs_in_nature/node_partitioning/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://vishvAsa.github.io/notes/math/graphTheory/graphs_in_nature/node_partitioning/</guid>
      <description>&lt;h2 id=&#34;number-of-partitions-k&#34;&gt;Number of partitions, k&lt;/h2&gt;&#xA;&lt;p&gt;See statistics ref for further info.&lt;/p&gt;&#xA;&lt;h2 id=&#34;minimum-cut-objectives&#34;&gt;Minimum cut objectives&lt;/h2&gt;&#xA;&lt;p&gt;Maybe find \(argmin_{(V_{i})} cut((V_{i}))\): but \(V_{1} = V\) minimizes it. So, to balance the partitions, associate each vertex with a weight w(v), get W = diag(w(v)); define \(w(V_{i}) = \sum_{v \in V_{i}} w(v)\); minimize \(Q((V_{i})) = \sum \frac{cut(V_{i})}{w(V_{i})}\).&lt;/p&gt;&#xA;&lt;h3 id=&#34;ratio-normalized-cuts&#34;&gt;Ratio, normalized cuts&lt;/h3&gt;&#xA;&lt;p&gt;If \(w(v) = 1\), get ratio cut objective fn. So, ratio cut is trying to minimize the weight of cross-cut edges, averaged over the nodes.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
