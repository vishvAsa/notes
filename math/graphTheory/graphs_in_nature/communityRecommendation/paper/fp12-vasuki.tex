\documentclass{sig-alternate}
\input{packages}
\input{macros}
\input{MACPdef}

%
\def\sharedaffiliation{%
\end{tabular}
\begin{tabular}{c}}
%
\begin{document}
\conferenceinfo{RecSys2010,} {September 26--30, 2010, Barcelona, Spain.} 
\CopyrightYear{2010}
\crdata{978-1-60558-906-0/10/09}
\clubpenalty=10000
\widowpenalty = 10000

\title{Affiliation Recommendation using Auxiliary Networks}
\numberofauthors{4}
\author{
\alignauthor Vishvas Vasuki
\alignauthor Nagarajan Natarajan
\and
\alignauthor Zhengdong Lu
\alignauthor Inderjit Dhillon
\sharedaffiliation
\affaddr{Department of Computer Sciences and ICES, University of Texas at Austin.}
}


\date{}

\maketitle

\begin{abstract}
Social network analysis has attracted increasing attention in recent years. In many social networks, besides friendship links amongst users, the phenomenon of users associating themselves with groups or communities is common. Thus, two networks exist simultaneously: the friendship network among users, and the affiliation network between users and groups. In this paper, we tackle the affiliation recommendation problem, where the task is to predict or suggest new affiliations between users and communities, given the current state of the friendship and affiliation networks. More generally, affiliations need not be community affiliations - they can be a user's taste, so affiliation recommendation algorithms have applications beyond community recommendation. In this paper, we show that information from the friendship network can indeed be fruitfully exploited in making affiliation recommendations. Using a simple way of combining these networks, we suggest two models of user-community affinity for the purpose of making affiliation recommendations: one based on graph proximity, and another using latent factors to model users and communities. We explore the two classes of affiliation recommendation algorithms suggested by these models. We evaluate these algorithms on two real world networks - Orkut and Youtube. In doing so, we motivate and propose a way of evaluating recommenders, by measuring how good the top 50 recommendations are for the average user, and demonstrate the importance of choosing the right evaluation strategy. The algorithms suggested by the graph proximity model turn out to be the most effective and efficient. This use of link prediction techniques for the purpose of affiliation recommendation is, to our knowledge, novel.
\end{abstract}

\category{H.2.8}{Database applications - Data mining}{}
\terms{Algorithms, Experimentation}

\section{Introduction}
\label{Introduction}
There has been an explosion in the number of online social networks and their active members. This wealth of information in the social networks has driven prolific work on the analysis of the networks, understanding the processes that explain the evolution of the networks, modeling the spread of behavior through the networks, predicting their future state and so on.

Users of a social network tend to affiliate with communities. In some social networks, the groups are identified more by the preferences of the members of the social network than by direct declaration: e.g. the genre of movies that a set of customers tend to patronize more often in Netflix. Online social networks like Facebook, Orkut and Live Journal are more interesting examples because the affiliation networks here are explicitly established by the members of the network. Thus, two networks exist simultaneously: the friendship network among users, and the affiliation network between users and groups.

\paragraph*{The problem}
Group formation and evolution in social networks\cite{GroupFormation}, and co-evolution of social and affiliation networks\cite{Coevolution} have been recently studied. One of the interesting challenges in social network analysis is the affiliation recommendation problem, where the task is to recommend communities to users. The fact that the social and affiliation networks ``co-evolve'' suggests that a better solution to the affiliation recommendation problem can be obtained if the friendship network is considered along with the affiliation network. This problem setting has applications beyond community recommendation. Affiliations, for example, can be interpreted in general as a user's taste for an item. Neither is it limited to social networks. For example, in biology, the friendship network can correspond to a network among genes, whereas the affiliation network can correspond to a network between genes and traits/ diseases, and the affiliation recommendation problem can be viewed as one of identifying genes affecting the expression of a disease.

\paragraph*{Contributions}
We consider how one can model the interplay between users and communities in both the networks simultaneously. An ideal unifying model would not only explain the current state of the networks, but also help in predicting future relationships among the nodes. Using a simple way of combining these networks, we suggest and explore two ways of modeling the networks for the purpose of making affiliation recommendations. The graph proximity model is based on estimating the affinity between a user and a community by considering their proximity as nodes in a combined graph, while the latent factors model is based on the proposition that community affiliations arise from interactions of \textit{user} and \textit{group factors}. Each of these network models suggests affiliation recommendation algorithms.

We evaluate these algorithms on social networks from Orkut consisting of 9,123 users and 75,546 communities, and Youtube consisting of 16,575 users and 21,326 communities. We propose a way of evaluating affiliation recommendations, by measuring how good the top 50 recommendations per user are, and demonstrate the importance of designing the right evaluation strategy. Of the algorithms proposed, those suggested by the graph proximity model turn out to be the most effective and efficient. This use of link prediction techniques for the purpose of affiliation recommendation is, to our knowledge, novel. We show that information in the friendship network can be used effectively for affiliation recommendation. We also observe that the benefit we derive from the social network in affiliation recommendation is strongly contingent on how the problem is modeled and what algorithms are used.

\paragraph*{Overview}
We now provide a brief overview of the organization of the paper. In Section \ref{Models}, we consider a network formed by merging the friendship and affiliation networks and introduce two models of the behaviour of nodes in this network: the graph proximity model, and the latent factors model, and explore recommendation algorithms that arise from these models. In Section \ref{Related work}, we consider how the proposed models and algorithms relate to prior work. Then, in Section \ref{Experimental Evaluation}, we describe our chosen evaluation strategy, and using experiments on real world networks, we evaluate the effectiveness of various algorithms in affiliation recommendation in practical scenarios. Finally, in Section \ref{Conclusion and Future Work}, we conclude with a summary of our findings, and a discussion of future lines of research in this direction.


\section{Models}
\label{Models}
In this section, we first establish the notation used, and then pose the affiliation recommendation problem as a \emph{ranking} problem. Then we describe a natural way of combining the friendship and affiliation networks into a single graph. In the subsections that follow, we describe affiliation recommendation approaches based on the graph proximity model and those based on the latent factors model.

\paragraph*{Notation}
We use $N_u$ to denote the total number of users in the affiliation network and $N_g$ to denote the total number of communities in the affiliation network. $\A \in \mathbb{R}^{N_u \times N_g}$ denotes the user $\times$ group adjacency matrix of affiliation network $\calA$. $\SS \in \mathbb{R}^{N_u \times N_u}$ denotes the user $\times$ user adjacency matrix of friendship network $\calS$. Other notation will be introduced as needed.

\paragraph*{As a ranking problem}
The task is to recommend affiliations to a given user. This problem can be posed as a problem of ranking various affiliations in the order of the user's interest in joining them. The methods we describe here to solve this problem rely on assigning scores to various affiliations in order to rank them. The task of an affiliation recommendation algorithm can be viewed as one of generating an $N_u \times N_g$ score matrix. 

\subsection{Prediction on the Combined Graph}
Consider the adjacency matrices $\A$ and $\SS$. For now, we assume $\SS$ to be symmetric (or equivalently $\calS$ to be undirected), although a non-symmetric extension to our model can be easily obtained. Clearly, $\SS$ corresponds to an undirected graph among users and $\begin{bmatrix}
 0 & \A \\
\A^T & 0
\end{bmatrix}$
corresponds to an undirected bipartite graph between users and groups. Despite the heterogeneity of the two types of ``links", it is rather natural to consider a graph $\calC$ between all the users and groups, with the combined adjacency matrix
\[\C =
\begin{bmatrix}
\lambda \SS & \A \\
\A^T & 0
\end{bmatrix},
\label{e:C}
\]
where the heterogeneity of two types of links is reduced to a single parameter $\gl \geq 0$, that controls the ratio of the weight of friendship to the weight of group membership. Clearly when $\gl = 0$, the user-user friendship ceases to play a role in this joint graph, and it simply degenerates to the bipartite affiliation graph.

As in the case of prediction with a single graph, the prediction on $\calC$ can be carried out from the following two perspectives:
\begin{itemize}
\item {\bf Graph Proximity Model:} We assume that the entire graph is known, and that the prediction of new or unobserved links is based on an estimated proximity in $\C$ between nodes.
\item {\bf Latent Factors Model:} We model the graph as a matrix, some of whose zero entries are actually ones, while modelling all entries as the product of latent factors.
\end{itemize}
We will elaborate on the two perspectives in the following two subsections.

\subsubsection{Graph Proximity Model}
\label{Graph Proximity Model}
As described earlier, the affiliation network can be modelled by a graph. The graph proximity model assumes that the probability of there arising a link between two nodes in a graph is based on an estimated proximity between the two nodes. The proximity of two vertices can be calculated as the weighted sum of the number of paths connecting the two with varying lengths. This is the underlying mechanism of many link prediction models in the context of social network analysis. Consider the widely-used \textsf{Katz} measure\cite{KleinbergLinkPred} on the friendship network $\calS$. The proximity is given by
\[
\textsf{Katz}(\SS; \beta) = \beta \SS + \beta^2 \SS^2 + \beta^3 \SS^3 + \cdots.
\]
where the weights of paths decay exponentially with the length.

A simple extension of \textsf{Katz} to the bipartite graph $\calA$ is
\begin{eqnarray}
\textsf{Katz}(\A; \beta) \hspace{-6pt} &= & \hspace{-6pt}(\beta \A\A^T + \beta^2 (\A\A^T)^2 + \beta^3 (\A\A^T)^3 + \cdots) \A \nonumber \\
\hspace{-6pt} &= & \hspace{-6pt} \beta \A\A^T\A + \beta^2 (\A\A^T)^2\A + \cdots.
\label{e:extKatz}
\end{eqnarray}
where in the co-occurrence matrix $\A\A^T$, two users $i$ and $j$ are considered connected if $i$ and $j$ belong to at least one same group, i.e. $(\A\A^T)_{ij} > 0$. In this case, we consider the paths of the following types
\[
\text{user $i \, \xrightarrow{\A\A^T}\, j \,\cdots \xrightarrow{\A\A^T}\, k \,  \xrightarrow{\A}$ to group $n$}
\]
The intuition in considering $\A\A^T\A$ is if user $i$ shares some community with user $j$, it is likely that $i$ will join some other community $j$ belongs to. The higher order terms can be interpreted in a similar way.

Consider the following Katz-measure proximity matrix on the combined graph $\calC$
\[
\mathsf{katz}(\calC; \beta) = \beta \C + \beta^2 \C^2 + \beta^3 \C^3 + \cdots.
\]
The user-community block of the above matrix is simply
\begin{equation}
\mathsf{katz}(\calC; \beta)_{12} = \beta \A + \beta^2 \lambda \SS \A +  \beta^3(\lambda^2 \SS^2 \A + \A \A^T \A) + \cdots
\label{e:combKatz}
\end{equation}
Clearly (\ref{e:combKatz}) generalizes the normal Katz on the bipartite graph $\A$
by also considering some paths like
\[
\text{user $i \xrightarrow{\SS}j\xrightarrow{\A}$ group $n$ (in $\C^2$)}
\]
and
\[
\text{user $i \xrightarrow{\SS}j\xrightarrow{\A\A^T}k \xrightarrow{\A}j$ group $n$ (in $\C^4$)}.
\]
$\mathsf{katz}(\calC; \beta)_{12}$ can then be used as the score matrix.

Since the computation of the Katz matrices as described above is expensive, we consider a truncated Katz matrix, $$tKatz(T, k, \gb) = \sum_{i=1}^{k} \gb^i T^i.$$ For computing the Katz matrices for the graphs described by $\A$ or $\C$, a conservative estimate of the computational cost is $O(N_u \times nnz)$, where $nnz$ is the number of non-zeros in $(\A\A^T)^k$.

\subsubsection{Latent Factors Model}
\label{Latent Factors Model}
We now describe the latent factors model, consider the optimization problem it tries to solve, and examine some of its properties. In this model, the zeros in the adjacency matrix of the affiliation network, $\A$ may be viewed as being unobserved entries with a huge prior belief in favor of them being actually zero. Every user $i$ and community $j$ are assumed to have a low dimensional representations $u_i,\ g_j$. The affinity of a user $i$ to a community $j$ is assumed to correspond to $u_i^{T} g_j$. In other words, users and communities with a high inner product are assumed to be connected to each other; that is to say: $$\A_{i, j} \approx u_i^T g_j.$$

In matrix form, we express this as
$$\A \approx \U^T \G,$$
where $\U \in \bbR^{d \times N_u}$ is the matrix of user factors and $\G \in \bbR^{d \times N_g}$ is the matrix of group factors. Note that $\text{rank}(\U) \leq d,\ \text{rank}(\G) \leq d,\ d \ll N_u, N_g$.

To get factors which account for both the observed entries in $\A$ as well as the interactions in $\SS$ we consider the following generalized combined network,
\begin{equation}
\C'(\lambda, \D) =
\begin{bmatrix}
\lambda \SS & \A \\
\A^T & \D
\end{bmatrix},
\label{e:generalizedCombined}
\end{equation}
where $\D$ is the \emph{derived} similarity between groups which is \emph{not} observed. Note that $\C = \C'(\lambda, 0)$. Also, we approximate $\C'$ as an interaction of user and group factors of the individual graphs. i.e.
\[\C'(\lambda, \D) \approx
\begin{bmatrix}
\U^T \\
\G^T
\end{bmatrix}
\begin{bmatrix}
\U & \G
\end{bmatrix}.
\]
The same set of user factors drive both the friendship and affiliation network creations. We therefore want to find the user factors $\U$ and the group factors $\G$ such that the reconstruction error on the observed entries in $\C'$,
\begin{equation}
\|\U^T \U -\lambda \SS \|^2 + 2\|\U^T \G -\A \|^2 + \|\G^T\G - \D\|^2
\label{e:objective}
\end{equation}
is minimized.

\paragraph*{Role of $\lambda$}
Intuitively, in equation (\ref{e:objective}), $\gl$ controls the contribution of $\SS$ in deciding the user factors. The larger the $\lambda$, the learned factor model describes the friendship network $\calS$ better, and correspondingly the affiliation network is described less well.

\paragraph*{Choice of D}
The derived similarity between the communities $\D$ in the combined matrix $\C'$ can be approximated using proximity between communities in the graph corresponding to $\C'$. It follows that a potential choice is $\D = \A^T \A$, which is simply the number of users which any two communities share. One may also consider weighing the contribution of $\D$ with $\gl$, which is the weight factor learnt for $\SS$. We will see later that the experiments suggest that the choice of $\D$ is not very important, and that the information from $\D$, when derived from A, is redundant.

\subsection{Solution to the optimization problem}
The analytical solution to the minimizing $\set{\U, \G}$ of the objective function in (\ref{e:objective}) is given by the SVD of $\C'$. Specifically,
\begin{eqnarray}
 \textbf{argmin}_{\U, \G} \{\|\U^T \U -\lambda \SS \|^2 + 2\|\U^T \G -\A \|^2 + \nonumber\\ \|\G^T\G - \D\|^2 \} =  \text{SVD}(\C', d)
\end{eqnarray}
where SVD($\C', d$) denotes the rank-$d$ singular value decomposition of matrix $\C'$, i.e, $\C' \approx \U \bSigma \G^T$, where
$\bSigma$ is the $d \times d$ matrix of singular values, $\U$ is the matrix of $d$ leading left singular vectors, and $\G$ is the matrix of $d$ leading right singular vectors. We can interpret the low rank approximation $\U \bSigma \G^T$ as the score matrix.


\section{Related work}
\label{Related work}
Increasing attention to recommendation systems in general can be attributed primarily to commercial enterprises like Netflix and Amazon, where making good recommendations for the customers is important for business. A huge body of literature studies the problem of group recommendation, where the problem is to recommend items or products to a group of users in a friendship network.  Affiliation recommendation for users of a friendship network, however, is relatively new and less studied.

\subsection{Joint matrix factorization models}
We now examine the relationship of the latent factors model proposed in this paper to a variety of other models proposed recently. Bader and Chew\cite{baderChew08}, in the context of information retrieval, tackle the problem of applying LSA to multi-lingual corpora. In such corpora, one has access to term-similarity information along with term-document matrices corresponding to various languages. In order to derive low dimensional term and document factors which account for information from both these sources, they form a joint matrix similar to our combined adjacency matrix C and compute its SVD. However, unlike this work, \cite{baderChew08} does not deal with the item recommendation problem, and it does not view this joint matrix as arising out of a pair of networks.

We will now consider two other joint matrix factorization models: One class of models uses a probabilistic collaborative filtering to approach the problem, whereas another tackles the problem of combining information from multiple sources from the perspective of joint matrix factorization.

\subsubsection{Probabilistic Collaborative Filtering Models}
Collaborative filtering is a natural way to approach the affiliation recommendation problem. Typically collaborative filtering is applied to user-item preference problems. This is based on the simple idea that users with similar tastes behave similarly.

This approach has recently been applied to the affiliation recommendation problem by Chen et al\cite{GoogleCFLatent}. The authors examined the use of Latent Dirichlet Allocation (LDA) in affiliation recommendation. The LDA approach does not use information from the friendship network among users. So, here we briefly examine the relationship between the latent factors model we propose and this LDA based approach, while ignoring the friendship network aspects of our model.

Consider the objective (\ref{e:objective}) we are trying to minimize. In the proposed model, if we ignore the constraint that the user factors $\U$ do not result in too large a deviation from $\SS$, we are essentially trying to find a low rank approximation to $\A$ in terms of the Frobenius norm. The solution which minimizes that objective is given by the SVD of $\A$. This is the Latent Semantic Analysis approach (LSA), which has long been exploited for similar problems in the area of information retrieval. pLSA, or probabilistic LSA \cite{HofmannPLSI}, instead proposes a statistical model for the process generating $\A$ and then learns the model parameters which are most likely to have generated the observations in $\A$. These parameters can then be used in finding a low rank approximation to $\A$, in terms of the KL divergence. It can thus be viewed as the probabilistic version of LSA. LDA, where Dirichlet priors are added to pLSA's generative model, can be viewed as the Bayesian version of pLSA. Thus, the LDA based approach to the affiliation recommendation problem may be viewed as trying to find a low rank approximation to $\A$, albeit from a probabilistic, Bayesian perspective, while ignoring information from $\SS$.

Combinatorial collaborative filtering\cite{GoogleCCF} is another work in the same vein. Unlike the LDA based approach, however, the probabilistic model of user-community relationships used in this work utilizes information not only from $\A$, but also from text descriptions of various communities. Next, we examine a couple of closely related matrix factorization models.

\subsubsection{Linked Matrix Factorization Models}
Tang et al have proposed Linked Matrix Factorization (LMF) \cite{WeiLMF} as a way of combining information from multiple graphs on the same set of entities, in order to make more accurate inferences. However, they tackle a different problem, namely, clustering. The link between their network model and ours is established by the objective functions that we optimize. The LMF model tries to simultaneously find a low rank approximation for the adjacency matrix of each network, using matrix factorization. Each such matrix factorization has a source-specific factor matrix, $\Lambda^{(m)}$, and a factor matrix, $\PP$, that is shared by all the sources. The objective function of LMF is effectively to minimize the quantity,
\begin{equation*}
\displaystyle\sum_{i=1}^{M}\|\A^{(m)} - \PP \Lambda^{(m)} \PP^T\|_{F}^2
\label{e:LMF}
\end{equation*}

Comparing this to (\ref{e:objective}), we see that $\U$, which represents the user factors, is shared by the two sources of information, i.e., $\A$ and $\SS$. However, an important distinction is that we have two graphs which share only one set of entities in common, whereas in LMF, each source of information is a network on exactly the same set of users.

Singh and Gordon have proposed a model for relational learning called Collective Matrix Factorization\cite{SinghCMF}. They suggest a generalized framework for inferring relations, given a set of entities and observed relations among them. This model factors multiple source matrices simultaneously, and uses common factors for approximation whenever the same entity participates in multiple relations. It allows different loss functions for each matrix approximation, and combines the information from multiple relations using weights which reflect the relative importance for each relation. This essentially generalizes the idea of Linked Matrix Factorization. The Latent Factors Model proposed in this paper uses the parameter $\gl$ to determine the contribution of the friendship network $\SS$ in generating the user factors.

The above mentioned papers use optimization techniques based on the alternating least squares approach, we use SVD which efficiently solves the optimization problem posed by the latent factors model.

\subsection{Co-evolution of social and affiliation networks}
Researchers have studied the effects of friendship ties on affiliations in other contexts, like the growth and evolution of social networks\cite{GroupFormation}, and spread of influence through a social network\cite{KleinbergInfluence, ChenInfMax}. They tend to model the dependence of a user joining a group on the number of friends the user already has in the group. Zheleva et al\cite{Coevolution} proposed a unified model for the generation of social and affiliation networks, and observed that the social network is one of the factors that influences the evolution of affiliation network. Our idea that friendship network combined with the affiliation network can be exploited in making affiliation recommendations is inspired by this line of research.

\section{Experimental Evaluation}
\label{Experimental Evaluation}
We first introduce the datasets on which we conduct our experiments, and describe the experiment setup. We then describe our methodology for comparing the performance of various algorithms at the affiliation recommendation task. Finally, we discuss the results of experiments which apply the algorithms based on both the graph proximity model and the latent factors model in performing affiliation recommendation.

\subsection{Data}
We use two popular online social networks \textit{Orkut} and \textit{Youtube}, both operated by Google, for our experiments. The users of both the social networks explicitly identify themselves as belonging to some \textit{communities} or \textit{groups}. Thus, for each of the networks we have adjacency matrix $\A$ that identifies the memberships of the users in the groups and adjacency matrix $\SS$ that identifies friendships among users. For our experiments, we used data gathered by Mislove et al \cite{Mislove}. We compare the predictive ability of the algorithms using sub-networks extracted from these large networks \footnote{We extracted a small connected component from the large network for the propose of experimentation.}. The statistics for these networks are presented in Table \ref{tab:datasets}.

\begin{table}[h!]
\centering
\begin{tabular}{| l | r | r |} \hline
Feature & Orkut & Youtube\\ \hline
$N_{u}$ & 9123 & 16575 \\ \hline
$N_{g}$ & 75546 & 21326 \\ \hline
Average number of groups per user & 55.8 & 10.5\\ \hline
Minimum number of groups per user & 4 & 4\\ \hline
Mode of number of groups per user & 6 & 4\\ \hline
Average number of users per group & 6.7 & 8.1\\ \hline
Mode of number of users per group & 2 & 1 \\ \hline
Minimum number of users per group & 1 & 1\\ \hline
Average number of friends per user & 46 & 11.7\\ \hline
Mode of number of friends per user & 2 & 1\\ \hline
\end{tabular}
\caption{Details about the datasets used in experiments.}
\label{tab:datasets}
\end{table}

\subsection{Experiment setup}
For every user $u$, let $\E_u = \set{(u,v) \ | \ \A_{u,v} = 1}$ denote the affiliations of $u$, as observed in a given affiliation network $\A$. Invariably in all the experiments, we set aside a subset of these affiliations $\E_{u}^{(t)} \subset \E_u$ as test data (we use $|\E_u^{(t)}| = 30 \% |\E_u|$). The remaining affiliations $\E_u^{(tr)} = \E_u \setminus \E_u^{(t)}$ are used as training data for the recommendation algorithms.

All of our recommendation algorithms require ``learning'' parameters for some model of the affiliation process, and hence for the purposes of learning the parameters, we use a set of \textit{validation} edges $\E_u^{(v)} \subset \E_u^{(tr)}$ (we use $|\E_u^{(v)}| = 30 \% |\E_u^{(tr)}|$). During the validation process, we compare different model parameters based on the number of correct edges among $25 N_u$ recommendations \footnote{This is chosen because, in Section \ref{Evaluation method}, we argue that a predictive model should be judged based on the quality of its top few recommendations.} made using the model.

\subsubsection{Evaluation method}
\label{Evaluation method}
We now describe our methodology for evaluating the performance of an affiliation recommendation algorithm. We first introduce notions of interest, such as precision, sensitivity, specificity, ROC and AUC. We then describe the way in which we evaluate the performance of a recommendation algorithm based on its top 50 recommendations to the average user. We then demonstrate the importance of choosing the right evaluation method for the community recommendation task by showing that using a different, but less appropriate, evaluation strategy yields different results.

Three commonly used measures of quality of solutions in information retrieval and classification tasks are \textit{Precision}, \textit{Recall} or \textit{Sensitivity} and \textit{Specificity}. \textit{Precision} measures the exactness or fidelity of the prediction while \textit{Sensitivity} measures the completeness of the prediction. Suppose that the recommendation algorithm makes $n$ recommendations to a user. Then, \textit{Precision} is defined as the ratio of the number of correctly identified positives (true positives) to $n$, and \textit{Sensitivity} is the ratio of the number of correctly identified positives to the total number of positives i.e. $|\E_u^{(t)}|$. \textit{Specificity}, on the other hand, measures the ability of the recommender to exclude uninteresting affiliations from the recommendations it makes. It is defined as the fraction of such ``negative affiliations'' correctly excluded from the recommendation. All three of these performance measures range from 0 to 1.

Often, one is interested in evaluating the performance of a recommendation algorithm not for a single value of the number of recommendations $n$, but for the entire range of $n$. For a given recommendation algorithm and a user, sensitivity is a non-decreasing function of $n$, while specificity is a monotonically non-increasing function of $n$. The relationship between the increase in sensitivity, as $n$ increases, with the decrease in specificity is of interest in comparing the quality of recommendations. For a good recommendation, as $n$ increases, sensitivity increases without a big drop in specificity. The Reciever Operating Characteristics (ROC) curve, which is a plot of sensitivity vs (1 - specificity) for all values of $n$, is a common way of comparing the performance of classification algorithms over the entire range of $n$ (or equivalently cutoff scores). Area under the ROC curve, or AUC, is then used as a way to compare different classification algorithms: the greater the AUC, the better the algorithm's sensitivity vs 1-specificity tradeoff.

Consider a social network website, like Orkut or Facebook; or a vendor like Netflix which sells movies. They would be interested in making, let us say, five pages of recommendations to their users, but not much more than that: certainly not a hundred. Also, irrespective of whether a user participates in five communities or seventy, the social networking website would probably want to make roughly the same number of recommendations per user. So, we choose to evaluate the recommendation algorithms we propose based on their top 50 recommendations. We do this by examining a slice of the ROC curve formed by measuring the sensitivity and specificity the recommendation algorithm achieves for an average user at regular intervals between $n = 1$ and $n = 50$. To do this, for a given $n$, we compute the sensitivity and specificity for every user in the network, and take the mean of these values to be the average sensitivity and average specificity. We then plot the average sensitivity vs 1 - average specificity curve, as in Figure \ref{fig:summaryResults}. Note that comparisons made using this method are statistically robust, as the sensitivities and specificities of recommendation algorithms are averaged over, for example, 9500 users in Orkut and 16000 users in Youtube.

Let $k(n_u)$ be the number of ``good recommendations'' made by a recommendation algorithm for a user $u$, when it makes $n_u$ recommendations to that user. Then, the above ``per user'' sensitivity measure calculates $N_u^{-1} \sum_u \displaystyle\frac{k(n_u) }{|\E_u^{(t)}|}$. In our experiments, we will use $\forall u: n_u = 50$.

Contrast this with finding the ``global'' sensitivity $\dfrac{k'(n)}{\sum_u |\E_u^{(t)}|}$, where $k'(n)$ denotes the number of ``good recommendations'' made by a given recommendation algorithm while making $n$ predictions in total. For a fixed $n$, this ``global'' sensitivity is proportional to precision, and is a commonly used measure of performance of link prediction algorithms in the context of social network analysis. Note that, in this case, while $n = \sum_u n_u$, there is no guarantee that, for two given users $u$ and $v$, $n_u = n_v$; indeed the recommendation algorithm, when asked to make $n$ recommendations, may not make any recommendations at all for some users. Therefore, this measure of goodness of a recommendation algorithm is not equivalent to the ``per user'' sensitivity described earlier.

Also, judging identical algorithms on identical datasets, using this alternate evaluation method can yield very different rankings of recommendation algorithms, as illustrated by comparing Figure \ref{fig:linkPredictionEvaluation} with Figure \ref{fig:summaryResults}. Hence, the choice of an appropriate method for evaluating affiliation recommendations is an important one. 

\begin{figure}[h]
  \begin{center}
    \subfigure[Orkut dataset]{\includegraphics[scale=0.5]{OrkutLinkPredictionEvaluation.eps}}
    \subfigure[Youtube dataset]{\includegraphics[scale=0.5]{YoutubeLinkPredictionEvaluation.eps}}
  \end{center}
  \caption{Comparison of recommendation algorithms using ``global sensitivity'' yields results different from Figure \ref{fig:summaryResults} while making $\sum_u E_u$ recommendations in total (See Section \ref{Evaluation method}).}
  \label{fig:linkPredictionEvaluation}
\end{figure}

\begin{figure}[h]
  \begin{center}
    \subfigure[Orkut dataset]{\includegraphics[scale=0.4]{summaryOrkut.eps}}
    \subfigure[Youtube dataset]{\includegraphics[scale=0.4]{summaryYoutube.eps}}
  \end{center}
  \caption{Comparison of recommendation algorithms based on graph proximity and latent factors models, as described in Section \ref{Evaluation method}. The leading slice of the ROC curve is shown. The graph proximity based predictors consistently outperform latent factors based predictors in the two datasets. See Section \ref{Results and Discussion} for discussion.}
  \label{fig:summaryResults}
\end{figure}

\begin{figure}[h]
  \begin{center}
    \includegraphics[scale=0.4]{summarySVDOrkut.eps}
  \end{center}
  \caption{Comparison of latent factors based algorithms for various choices of $\D$, for the Orkut dataset. See Section \ref{Results and Discussion} for discussion.}
  \label{fig:summarySVD}
\end{figure}

\subsection{Results and Discussion}
\label{Results and Discussion}
In this section, we report and analyse the performance of the various recommendation algorithms, based on the graph proximity model and latent factors model discussed in Section \ref{Models}. We compare the performance of the graph proximity based methods with latent factors based methods based on the average sensitivity and average specificity metrics introduced earlier, for a given number of recommendations in the range [5,50] (in steps of 5).

The results are reported in Figure \ref{fig:summaryResults}.
Consider the performance of the recommendation algorithms on the Orkut dataset in Figure \ref{fig:summaryResults} (a). SVD($\A$) gives the lowest performance of all the methods. SVD($\C$) performs better than SVD($\A$), which is expected given that it uses information from the friendship network $\SS$ in addition to the information from affiliation network $\A$. For the average user, the graph proximity model based methods significantly outperform latent factors based methods as observed from the figure. In particular, we see that tKatz($\C$) performs much better than tKatz($\A$), which in turn outperforms latent factor based methods. We see that the information in the friendship network indeed proves highly beneficial to making affiliation recommendations and graph proximity based methods exploit this information the most.

Another interesting comparison of latent factor methods based on the choice of $\D$ in constructing the combined network $\C'$ given in (\ref{e:generalizedCombined}), is presented in Figure \ref{fig:summarySVD}. We observe that the choice of $\D$ does not appear to make any significant difference in the performance of the recommendation algorithm. In the plot, $\D_2$ denotes using $\A^{T}\A$ for $\D$ in $\C'$  while $\D_3$ denotes using $\lambda \A^{T}\A$, where $\lambda$ is also the weight associated with $\SS$ in the combined graph. Though, in case of the Orkut dataset, we see that SVD($\C', \D$) performs slightly better than SVD($\C$), the choice of $\D \neq 0$ does not affect the performance. In case of Youtube (plots not shown), our experiments indicate that $\D$ is not useful at all. The potential choices for $\D$ do not perform any better than $\D = 0$.

The summary of performances of the algorithms on the Youtube dataset is shown in Figure \ref{fig:summaryResults} (b). We observe that the case for Youtube is similar to that of Orkut, in that graph proximity based algorithms significantly outperform latent factors based algorithms. In particular, tKatz($\C$) is highly successful compared to the other methods. 

The best parameters learnt by the various algorithms are presented in Table \ref{tab:parameters}. Note that the best parameter $\beta = 10^{-12}$ implies that the calculated tKatz measure was effectively using the common neighbors method. In other words, users and communities connected by path lengths 5 or more are not useful in making affiliation recommendations.

\begin{table}[h!]
\centering
\begin{tabular}{| c | p{2.4cm} | p{2.4cm} |} \hline
Algorithm&Orkut&Youtube\\ \hline
SVD($\C$) & $d=50, \gl = 0.8$ & $d = 90, \gl = 1$ \\ \hline
SVD($\C'(\lambda \A^{T} \A)$) & $d = 60, \gl = 0.6$ & $d = 70, \gl = 1$ \\ \hline
tKatz($\A$) & $\gb = 10^{-12}$ & $\gb = 10^{-12}$ \\ \hline
tKatz($\C$) & $\gb = 0.01, \gl = 0.2$ & $\gb = 0.1, \gl = 0.4$ \\ \hline
\end{tabular}
\caption{Best parameters learned by the recommendation algorithms using validation.}
\label{tab:parameters}
\end{table}

We see that the recommendation algorithms perform consistently across the two datasets, and the evaluations are robust as the specificities and sensitivities are averaged over 9000 users in Orkut and 16000 users in Youtube.

\section{Conclusion and Future Work}
\label{Conclusion and Future Work}
In this paper, we have tackled the affiliation recommendation problem, where the task is to recommend new affiliations to a given user, given the current state of the friendship and affiliation networks. We show that information from the friendship network can indeed be fruitfully exploited in making affiliation recommendations. This auxiliary source of information was hitherto not used in making community recommendations.

Using a simple way of combining these networks, we suggested two ways of modeling the networks for the purpose of making affiliation recommendations (Section \ref{Models}). The first of these approached the problem from the graph proximity viewpoint, whereas the second modelled the interactions of users and groups in the two networks using latent factors derived from optimizing towards a joint matrix factorization objective. We studied the algorithms suggested by these models on real world networks (Section \ref{Experimental Evaluation}). We motivated and proposed a way of evaluating recommenders, by measuring how good the top 50 recommendations are, and demonstrated the importance of choosing the right evaluation strategy. Algorithms suggested by the graph proximity model turn out to be the most effective, based on experiments on large real world data-sets. These results show that the application of techniques from social network link prediction in affiliation and item recommendation is a promising one.

\subsection{Future Work}
In this paper, we have tackled the affiliation recommendation problem, where the task is to recommend new affiliations to a given user, given the current state of the friendship and affiliation networks. We show that information from the friendship network can indeed be fruitfully exploited in making affiliation recommendations. This auxiliary source of information was hitherto not used in making community recommendations.

Using a simple way of combining these networks, we suggested two ways of modeling the networks for the purpose of making affiliation recommendations (Section \ref{Models}). The first of these approached the problem from the graph proximity viewpoint, whereas the second modelled the interactions of users and groups in the two networks using latent factors derived from optimizing towards a joint matrix factorization objective. We studied the algorithms suggested by these models on real world networks (Section \ref{Experimental Evaluation}). We motivated and proposed a way of evaluating recommenders, by measuring how good the top 50 recommendations are, and demonstrated the importance of choosing the right evaluation strategy. Algorithms suggested by the graph proximity model turn out to be the most effective, based on experiments on large real world data-sets. These results show that the application of techniques from social network link prediction in affiliation and item recommendation is a promising one.

\subsection{Future Work}
There is the intriguing possibility of using an affiliation network for link prediction in the friendship network. Discovering techniques and models which do this effectively seems to be a challenging research avenue. Our early experiments at doing this indicate that this is a much harder problem. The reasons for this are not yet clear, and this question seems fertile for further exploration.

Within the ambit of the affiliation recommendation problem itself, one may research the ways of fruitfully using even more sources of information. For example, Chen et al\cite{GoogleCCF} use information from textual description of communities along with the affiliation network to make affiliation recommendations. It might be useful to consider the social network together with this auxiliary information. Also, predictors based on latent factors model and the graph proximity model may be suited for different types of users, and creating a meta-predictor which combines predictions from both classes of predictors is another attractive research direction. Scalability is a challenge in using predictors based on the graph proximity models on massive datasets - both in terms of memory and in terms of computational cost\cite{savas10c}, and developing efficient predictors based on the graph proximity model will be part of future work.

\section{Acknowledgements}
We thank Prateek Jain and Berkant Savas for helpful discussions. We also thank Alan Mislove \cite{Mislove} for providing access to Orkut and Youtube datasets. Zhengdong Lu is supported by an ICES postdoctoral fellowship at UT Austin. This research was supported by NSF grants CCF-0916309 and IIS-0713142.

\begin{thebibliography}{10}

\bibitem{GroupFormation}
Lars Backstrom, Dan Huttenlocher, Jon Kleinberg, and Xiangyang Lan.
\newblock Group formation in large social networks: membership, growth, and
  evolution.
\newblock In {\em KDD '06: Proceedings of the 12th ACM SIGKDD International
  Conference on Knowledge Discovery and Data Mining}, pages 44--54, New York,
  NY, USA, 2006. ACM.

\bibitem{baderChew08}
Brett~W. Bader and Peter~A. Chew.
\newblock Enhancing multilingual latent semantic analysis with term alignment
  information.
\newblock In {\em COLING '08: Proceedings of the 22nd International Conference
  on Computational Linguistics}, pages 49--56, Morristown, NJ, USA, 2008.
  Association for Computational Linguistics.

\bibitem{ChenInfMax}
Wei Chen, Yajun Wang, and Siyu Yang.
\newblock Efficient influence maximization in social networks.
\newblock In {\em KDD '09: Proceedings of the 15th ACM SIGKDD International
  Conference on Knowledge Discovery and Data Mining}, pages 199--208, New York,
  NY, USA, 2009. ACM.

\bibitem{GoogleCFLatent}
Wen-Yen Chen, Jon-Chyuan Chu, Junyi Luan, Hongjie Bai, Yi~Wang, and Edward~Y.
  Chang.
\newblock Collaborative filtering for orkut communities: discovery of user
  latent behavior.
\newblock In {\em WWW '09: Proceedings of the 18th International Conference on
  World wide web}, pages 681--690, New York, NY, USA, 2009. ACM.

\bibitem{GoogleCCF}
Wen-Yen Chen, Dong Zhang, and Edward~Y. Chang.
\newblock Combinational collaborative filtering for personalized community
  recommendation.
\newblock In {\em KDD '08: Proceeding of the 14th ACM SIGKDD International
  Conference on Knowledge Discovery and Data Mining}, pages 115--123, New York,
  NY, USA, 2008. ACM.

\bibitem{HofmannPLSI}
Thomas Hofmann.
\newblock Probabilistic latent semantic indexing.
\newblock In {\em SIGIR '99: Proceedings of the 22nd annual International ACM
  SIGIR Conference on Research and development in Information Retrieval}, pages
  50--57, New York, NY, USA, 1999. ACM.

\bibitem{KleinbergInfluence}
David Kempe, Jon Kleinberg, and \'{E}va Tardos.
\newblock Maximizing the spread of influence through a social network.
\newblock In {\em KDD '03: Proceedings of the Ninth ACM SIGKDD International
  Conference on Knowledge Discovery and Data Mining}, pages 137--146, New York,
  NY, USA, 2003. ACM.
\vfill\eject

\bibitem{KleinbergLinkPred}
David Liben-Nowell and Jon Kleinberg.
\newblock The link prediction problem for social networks.
\newblock In {\em CIKM '03: Proceedings of the Twelfth International Conference
  on Information and Knowledge Management}, pages 556--559, New York, NY, USA,
  2003. ACM.

\bibitem{Mislove}
Alan Mislove, Massimiliano Marcon, Krishna~P. Gummadi, Peter Druschel, and
  Bobby Bhattacharjee.
\newblock Measurement and analysis of online social networks.
\newblock In {\em IMC '07: Proceedings of the 7th ACM SIGCOMM Conference on
  Internet Measurement}, pages 29--42, New York, NY, USA, 2007. ACM.

\bibitem{savas10c}
B.~Savas and I.~S. Dhillon.
\newblock Fast and accurate low rank approximation of massive graphs.
\newblock Technical report TR--10--18, Department of Computer Science, The
  University of Texas at Austin, 2010.

\bibitem{SinghCMF}
Ajit~P. Singh and Geoffrey~J. Gordon.
\newblock Relational learning via collective matrix factorization.
\newblock In {\em KDD '08: Proceeding of the 14th ACM SIGKDD International
  Conference on Knowledge Discovery and Data Mining}, pages 650--658, New York,
  NY, USA, 2008. ACM.

\bibitem{WeiLMF}
Wei Tang, Zhengdong Lu, and Inderjit~S. Dhillon.
\newblock Clustering with multiple graphs.
\newblock In {\em ICDM '09: Proceedings of the 2009 Ninth IEEE International
  Conference on Data Mining}, pages 1016--1021, Washington, DC, USA, 2009. IEEE
  Computer Society.

\bibitem{Coevolution}
Elena Zheleva, Hossam Sharara, and Lise Getoor.
\newblock Co-evolution of social and affiliation networks.
\newblock In {\em KDD '09: Proceedings of the 15th ACM SIGKDD International
  Conference on Knowledge Discovery and Data Mining}, pages 1007--1016, New
  York, NY, USA, 2009. ACM.

\end{thebibliography}

\end{document}
