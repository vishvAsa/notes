[[data]]
Language = 'C++'
"Operand Type" = 'name'
Feature = 'member'
Subfeature = ''
Importance = ''
"Implementation Type" = 'convention'
Syntax = 'xyz_'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'name'
Feature = 'immutable'
Subfeature = ''
Importance = ''
"Implementation Type" = 'convention'
Syntax = 'kxyz'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'name'
Feature = 'constant'
Subfeature = ''
Importance = ''
"Implementation Type" = 'convention'
Syntax = 'kDaysInAWeek'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'enum'
Feature = 'definition'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = '''
enum TypName {valueList}
enum wind_directions_t {NO_WIND, NORTH_WIND, SOUTH_WIND, EAST_WIND, WEST_WIND};
'''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'enum'
Feature = 'assignment'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = 'TypName var = ENUMVAL'
Description = 'Not TypName.ENUMVAL'

[[data]]
Language = 'C++'
"Operand Type" = 'enum class'
Feature = 'definition'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = '''
enum class Color { RED, GREEN=20, BLUE }; // int is base type
enum struct Color { RED, GREEN=20, BLUE }; //equivalent
enum struct Color : char { RED, GREEN='g', BLUE }; //equivalent
'''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'enum class'
Feature = '''
assignment
checking'''
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = '''
Color r = Color::BLUE;
switch(r) {
    case Color::RED   : std::cout << "red"   "\n"; break;
    case Color::GREEN : std::cout << "green" "\n"; break;
    case Color::BLUE  : std::cout << "blue"  "\n"; break;
}'''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'enum class'
Feature = 'convert to base type'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = '''
Color r = Color::BLUE;
// int n = r; // error: no scoped enum to int conversion
int n = static_cast<int>(r); // OK, n = 21'''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'type'
Feature = 'definition'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = '''
typedef T1 T2;
typedef ActualClass<A, B> NewClass;
NewClass o;'''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'generic'
Feature = 'declaration'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = '''
type var [= val];
auto var = val;
auto &v2 = var;'''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'generic'
Feature = 'instantiation'
Subfeature = 'stack'
Importance = ''
"Implementation Type" = ''
Syntax = 'type var;'
Description = 'this is compile time.'

[[data]]
Language = 'C++'
"Operand Type" = 'generic'
Feature = 'instantiation'
Subfeature = 'stack'
Importance = ''
"Implementation Type" = ''
Syntax = 'TYP xyz(args)'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'generic'
Feature = 'instantiation'
Subfeature = ''
Importance = ''
"Implementation Type" = 'caveat'
Syntax = ''
Description = 'When instantiating an object within a function, if stack space is used, the object is destroyed when the function exits. If another object tries to use the object after that point, a segmentation fault occurs. Function documentations usually refer to this as "taking ownership of the pointer". Hence use heap space.'

[[data]]
Language = 'C++'
"Operand Type" = 'generic'
Feature = 'constant'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = 'const typ name = val;'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'compile time expression'
Feature = ''
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = 'constexpr typ name = val;'
Description = '''
value known at compile time.
Like a macro - except value is evaluated and substituted.
Like an inline function.'''

[[data]]
Language = 'C++'
"Operand Type" = 'pointer'
Feature = 'definition'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = '''
T1 *[const] var; //Const ptr
const T1* var; // const value
T1 const *var; // const value
// T1 *var is exactly same as T1*'''
Description = '''
Pointer to a memory location holding value of a certain type.
var is the pointer, *var is a value of type T1'''

[[data]]
Language = 'C++'
"Operand Type" = 'pointer'
Feature = 'pointer to const'
Subfeature = ''
Importance = ''
"Implementation Type" = 'caveat'
Syntax = '''const T1* x = nullptr; // Won't work. Results in segfalut'''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'pointer'
Feature = 'definition'
Subfeature = 'function'
Importance = ''
"Implementation Type" = ''
Syntax = 'T1 (*ptr)(params)'
Description = 'points to functions with signature type fnName(params)'

[[data]]
Language = 'C++'
"Operand Type" = 'pointer'
Feature = 'instantiation'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = '''
ptr = &var;
ptr = heapObjPtr;'''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'pointer'
Feature = 'arithmetic'
Subfeature = ''
Importance = ''
"Implementation Type" = 'operator'
Syntax = ' + - '
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'pointer'
Feature = 'value'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = 'val = *ptr; *ptr = val;'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'pointer'
Feature = 'member value'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = 'v = ptr->val; ptr->val = v;'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'pointer'
Feature = 'null'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = 'nullptr'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'heap object'
Feature = 'instantiation'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = 'new constructor()'
Description = 'returns pointer'

[[data]]
Language = 'C++'
"Operand Type" = 'heap object'
Feature = 'instantiation'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = 'malloc(), calloc'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'heap object'
Feature = 'deletion'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = '''
free(ptr)
delete ptr'''
Description = '''
avoid running out of memory when new values need to be stored.
setting ptr=NULL is desirable to indicate deallocation'''

[[data]]
Language = 'C++'
"Operand Type" = 'heap object'
Feature = 'deletion'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = 'delete[] ptr'
Description = '''
essential for arrays
setting ptr=NULL is desirable to indicate deallocation'''

[[data]]
Language = 'C++'
"Operand Type" = 'heap object'
Feature = 'deletion'
Subfeature = 'caveat'
Importance = ''
"Implementation Type" = 'caveat'
Syntax = ''
Description = '''
Just referring to the memory location using a pointer or a constant reference and letting it go out of scope is not sufficient.
Explicitly delete it, or use scoped pointer.'''

[[data]]
Language = 'C++'
"Operand Type" = 'lvalue'
Feature = 'concept'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = ''
Description = '''
a non-temporary object or a non-member function.
 All variables, including nonmodifiable (const) variables, are lvalues.'''

[[data]]
Language = 'C++'
"Operand Type" = 'rvalue / prvalue'
Feature = 'concept'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = ''
Description = 'a temporary object (or a subobject thereof) or is a value not associated with any object.'

[[data]]
Language = 'C++'
"Operand Type" = 'lvalue reference / constant pointer'
Feature = 'instantiation'
Subfeature = 'pointer'
Importance = ''
"Implementation Type" = ''
Syntax = 'type &var = *ptr;'
Description = '''
Aka reference, alias. Very different from java reference. Not a pointer.
Conceptually a wrapper around a pointer/ memory location, guaranteed by compiler not to point to null.
Initial assignment is final.'''

[[data]]
Language = 'C++'
"Operand Type" = 'lvalue reference / constant pointer'
Feature = 'instantiation'
Subfeature = 'non-pointer'
Importance = ''
"Implementation Type" = ''
Syntax = '''
type var2; ..
type& var = &var2;'''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'lvalue reference / constant pointer'
Feature = 'deletion'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = 'delete &var;'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'const lvalue reference'
Feature = 'concept'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = ''
Description = 'Constant reference to a constant object (immutable within the scope).'

[[data]]
Language = 'C++'
"Operand Type" = '''
rvalue reference
(xvalue)'''
Feature = 'concept'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = '''
std::string bar = "bar-string";
  std::vector<std::string> myvector;
  myvector.push_back (foo);                    // copies
  myvector.push_back (std::move(bar));         // moves'''
Description = '''
Reference to a mutable object; assumed that the object will never be used again after going out of scope.
So, can use move constructor instead of copy constructor etc..'''

[[data]]
Language = 'C++'
"Operand Type" = '''
rvalue reference
(xvalue)'''
Feature = 'instantiation'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = 'string&& t3("val");'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = '''
rvalue reference
(xvalue)'''
Feature = 'instantiation'
Subfeature = 'from lvalue'
Importance = ''
"Implementation Type" = ''
Syntax = '''
T t2;
T&& t1(t2); // invalid : t2 is lvalue
T&& t1(std::move(t2)); // t2 now has unspecified value.'''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'unique pointer'
Feature = 'concept'
Subfeature = 'sole ownership'
Importance = ''
"Implementation Type" = ''
Syntax = ''
Description = 'Retains sole ownership of object.  No two unique_ptr instances can manage the same object.'

[[data]]
Language = 'C++'
"Operand Type" = 'unique pointer'
Feature = 'concept'
Subfeature = 'deallocation'
Importance = ''
"Implementation Type" = ''
Syntax = ''
Description = '''
unique_ptr managing the object is destroyed
unique_ptr managing the object is assigned another pointer via operator= or reset().
No copy constructor.'''

[[data]]
Language = 'C++'
"Operand Type" = 'unique pointer'
Feature = ''
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = '''
std::unique_ptr<T> ptr;
ptr.reset(new T());
std::unique_ptr<T> ptr2(new T());
'''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'unique pointer'
Feature = ''
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = '''
using ::util::gtl::MakeUnique;
uniqPtr = MakeUnique<SomeClass>();'''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'unique pointer'
Feature = 'internal pointer'
Subfeature = 'get'
Importance = ''
"Implementation Type" = ''
Syntax = 's.get()'
Description = 'Pointer to the managed object or nullptr if no object is owned.'

[[data]]
Language = 'C++'
"Operand Type" = 'unique pointer'
Feature = 'internal pointer'
Subfeature = 'set'
Importance = ''
"Implementation Type" = ''
Syntax = 't.reset(ptr);'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'unique pointer'
Feature = 'internal pointer'
Subfeature = '''
get
release ownership'''
Importance = ''
"Implementation Type" = ''
Syntax = 'ptr.release()'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'unique pointer'
Feature = 'dereference pointer'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = '*ptr;'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'unique pointer'
Feature = 'dereference pointer'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = '''
ptr->SomeFn();
'''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'unique pointer'
Feature = 'array'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = 'std::unique_ptr<P[]> t;'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'unique pointer'
Feature = 'check emptiness'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = 'if(ptr) ...'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'unique pointer'
Feature = 'transfer ownership'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = '''
std::unique_ptr<Foo> up7(new Foo);
    std::unique_ptr<Foo> up8(std::move(up7));'''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'shared pointer'
Feature = 'concept'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = 'std::shared_ptr<P>'
Description = '''
Object is deleted when last shared pointer to it is deleted. (An internal reference count is kept in the shared pointer)
This avoids attempting free() multiple times and resulting in segmentation faults - this can happen with scoped_ptr. Won't detect circular references.'''

[[data]]
Language = 'C++'
"Operand Type" = 'weak_ptr'
Feature = 'concept'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = ''
Description = ' non-owning smart pointer. It is used to reference a managed object (managed by a shared_ptr) without adding a reference count. '

[[data]]
Language = 'C++'
"Operand Type" = 'scoped pointer'
Feature = 'concept'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = ''
Description = '''
A container for a pointer which automatically deallocates memory occupied by the contained object when it is destroyed.
 neither transferable nor sharable.'''

[[data]]
Language = 'C++'
"Operand Type" = 'template class, function'
Feature = ''
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = '''
template <class T, int N> 
function or Class definition'''
Description = 'Useful for definining meta-classes and meta functions.'

[[data]]
Language = 'C++'
"Operand Type" = 'template class, function'
Feature = ''
Subfeature = 'concretization'
Importance = ''
"Implementation Type" = ''
Syntax = 'fnOrClassName<typeValue>'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'template class, function'
Feature = 'multiple fields'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = '''
template <typename Value, typename... Fields>
'''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'double'
Feature = ''
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = 'isnan(val)'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'double'
Feature = 'Infinity'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = '- std::numeric_limits<double>::infinity()'
Description = ''

[[data]]
Language = 'C'
"Operand Type" = 'struct'
Feature = 'definition'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = 'struct X { memberVar declaration};'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'struct'
Feature = ''
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = ''
Description = 'Like a class. Can have member functions.'

[[data]]
Language = 'C++'
"Operand Type" = 'union'
Feature = 'definition'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = 'union X { memberVar declaration};'
Description = 'Stores only one member at a time'

[[data]]
Language = 'C++'
"Operand Type" = 'class'
Feature = 'declaration'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = 'class X'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'class'
Feature = 'definition'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = 'class CL1 [: [modifier] CL2]+ {}'
Description = '''
accessModifier specifies the free-est access modifier members inherited from the superclass can have. If it is potected, for example, all public members of the superclass will be protected in the subclass. Private by default.

Friends are also inherited.'''

[[data]]
Language = 'C++'
"Operand Type" = 'class'
Feature = 'definition'
Subfeature = 'abstract'
Importance = ''
"Implementation Type" = ''
Syntax = '''
retType CL1(..) = 0;
// Include this empty function.'''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'class'
Feature = 'definition'
Subfeature = 'order'
Importance = ''
"Implementation Type" = 'convention'
Syntax = '''
public before protected before private.
methods before variables.'''
Description = '''
Typedefs and Enums
Constants (static const data members)
Constructors
Destructor
Methods, including static methods
Data Members (except static const data members)'''

[[data]]
Language = 'C++'
"Operand Type" = 'class'
Feature = 'constructor'
Subfeature = '''
initialization list,
superclass constructor'''
Importance = ''
"Implementation Type" = ''
Syntax = 'CL1(..) : superCL(..), fld1(val1) ..{}'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'class'
Feature = 'constructor'
Subfeature = ''
Importance = ''
"Implementation Type" = 'caveat'
Syntax = ''
Description = '''
fld1(val1) etc.. is the only place constant class members can be set.
Initialization lists handle non-static members defined in CL1, not superCL.
To initialize superCL members, use the constructor body, or superCL(..).'''

[[data]]
Language = 'C++'
"Operand Type" = 'class'
Feature = 'constructor'
Subfeature = 'redeclare superclass constructors'
Importance = ''
"Implementation Type" = ''
Syntax = 'using SupClass::SupClass;'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'class'
Feature = 'constructor'
Subfeature = 'copy constructor'
Importance = ''
"Implementation Type" = ''
Syntax = 'X(X& x) {...} '
Description = '''
By default a shallow-copier.
Also called whenever "pass by value" happens into or out of a function.'''

[[data]]
Language = 'C++'
"Operand Type" = 'class'
Feature = 'constructor'
Subfeature = 'move constructor'
Importance = ''
"Implementation Type" = ''
Syntax = '''
X(X&& x) {...
// code to delete stuff from within x.
} '''
Description = 'Always used with the return value, explicit calls to std::move() .'

[[data]]
Language = 'C++'
"Operand Type" = 'class'
Feature = 'constructor'
Subfeature = 'implicit conversion'
Importance = ''
"Implementation Type" = ''
Syntax = '''
CL1(T1 t1) {..}
explicit CL1(T2 t2) {..}'''
Description = '''
Single parameter constructor can be used by complier for implicit type conversion.
eg: f(t1) where f accepts CL1 objects.
Explicit keyword prevents this.'''

[[data]]
Language = 'C++'
"Operand Type" = 'class'
Feature = 'operator= '
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = ''
Description = 'Usually calls the copy / move constructor.'

[[data]]
Language = 'C++'
"Operand Type" = 'class'
Feature = 'destructor'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = '~CL1{}'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'class'
Feature = 'destructor'
Subfeature = 'virtual'
Importance = ''
"Implementation Type" = 'caveat'
Syntax = ''
Description = '''
Let B subclass A without a virtual destructor.
Now, A *b = new B(); delete b;
may result in a resource leak from just destroying members related to A. 
Hence declare virtual destructors always.'''

[[data]]
Language = 'C++'
"Operand Type" = 'class'
Feature = 'member'
Subfeature = 'static'
Importance = ''
"Implementation Type" = 'modifier'
Syntax = '''
static var;
static fnDefn'''
Description = 'Access/ set using CL1::var.'

[[data]]
Language = 'C++'
"Operand Type" = 'class'
Feature = 'member'
Subfeature = 'immutable'
Importance = ''
"Implementation Type" = 'modifier'
Syntax = 'const'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'class'
Feature = 'accessModifier'
Subfeature = 'private'
Importance = ''
"Implementation Type" = 'modifier'
Syntax = 'private'
Description = 'Accessible by intra-class code and by friends.'

[[data]]
Language = 'C++'
"Operand Type" = 'class'
Feature = 'accessModifier'
Subfeature = 'protected'
Importance = ''
"Implementation Type" = 'modifier'
Syntax = 'protected'
Description = 'Accessible by code within the class or its descendents, or by friends.'

[[data]]
Language = 'C++'
"Operand Type" = 'class'
Feature = 'accessModifier'
Subfeature = 'non-public'
Importance = ''
"Implementation Type" = 'convention'
Syntax = 'varName_'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'class'
Feature = 'accessModifier'
Subfeature = 'public'
Importance = ''
"Implementation Type" = 'modifier'
Syntax = 'public'
Description = '''
Accessible by everything.
Avoid this - restrict access, provide accessor methods.
Reason: preserve locality.'''

[[data]]
Language = 'C++'
"Operand Type" = 'class'
Feature = 'access friends'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = 'friend class className'
Description = 'If you put it in the private scope, friend class can access private members.'

[[data]]
Language = 'C++'
"Operand Type" = 'class'
Feature = 'access friends'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = 'friend retTyp fnName(paramTypeList)'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'class'
Feature = 'instantiation'
Subfeature = 'stack space'
Importance = ''
"Implementation Type" = ''
Syntax = 'className var(..);'
Description = 'Note that if the default constructor (which does not accept arguments) is being called, one can omit ().'

[[data]]
Language = 'C++'
"Operand Type" = 'class'
Feature = 'instantiation'
Subfeature = 'heap space'
Importance = ''
"Implementation Type" = ''
Syntax = 'className *obj = new className(..) '
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'class'
Feature = 'instantiation'
Subfeature = 'heap space'
Importance = ''
"Implementation Type" = 'convention'
Syntax = ''
Description = 'No naked "new". Use a smart pointer or container.'

[[data]]
Language = 'C++'
"Operand Type" = 'class'
Feature = 'instantiation'
Subfeature = 'use copy cosntructor'
Importance = ''
"Implementation Type" = ''
Syntax = '''
C c; 
C c1(c); // calls copy constructor'''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'class'
Feature = 'instantiation'
Subfeature = 'assignment constructor'
Importance = ''
"Implementation Type" = ''
Syntax = '''
C c; 
C c1 = c;'''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'class'
Feature = 'anomymous subclass singleton????'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = '''
new C() {
void someOveriddenFn(){...}
}'''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'method'
Feature = 'definition'
Subfeature = 'in class scope'
Importance = ''
"Implementation Type" = ''
Syntax = '[virtual] fnDefinition'
Description = 'virtual indicates dynamic dispatch when the method is called using a variable of the superclass type..'

[[data]]
Language = 'C++'
"Operand Type" = 'method'
Feature = 'definition'
Subfeature = 'outside class scope'
Importance = ''
"Implementation Type" = ''
Syntax = '[virtual] retType cls::fnName(..) {..}'
Description = 'virtual indicates dynamic dispatch when the method is called using a variable of the superclass type..'

[[data]]
Language = 'C++'
"Operand Type" = 'method'
Feature = 'definition'
Subfeature = 'const'
Importance = ''
"Implementation Type" = ''
Syntax = '[virtual] retType cls::fnName(..) const {..}'
Description = 'all member variables are effectively const within that member function (except variables marked "mutable"). If you have a const object, you can only call const member functions on it.'

[[data]]
Language = 'C++'
"Operand Type" = 'method'
Feature = 'call'
Subfeature = 'superclass fn'
Importance = ''
"Implementation Type" = ''
Syntax = '''
SupCls::meth(..);
obj->SupCls::meth(..); // from outside class'''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'method'
Feature = 'abstract'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = 'virtual fnName = 0'
Description = 'force overriding'

[[data]]
Language = 'C++'
"Operand Type" = 'method'
Feature = 'abstract'
Subfeature = ''
Importance = ''
"Implementation Type" = 'caveat'
Syntax = ''
Description = 'Essential when not defining the function in the superclass. Building may succeed, but linking may fail'

[[data]]
Language = 'C++'
"Operand Type" = 'operator'
Feature = 'definition'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = 'Use fnName like: operator->'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'function'
Feature = 'definition'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = 'returnType fnName(typ1 var1, typ2 var2 ..)'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'function'
Feature = 'definition'
Subfeature = 'anonymous'
Importance = ''
"Implementation Type" = ''
Syntax = 'auto func = [] (args) { ... }'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'function'
Feature = 'definition'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = '''
struct X {
void operator() (paramLst) {...} }
fn;'''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'function'
Feature = 'definition'
Subfeature = ''
Importance = ''
"Implementation Type" = 'convention Google'
Syntax = ''
Description = '''
Pass in (constant) references.
Return pointers.'''

[[data]]
Language = 'C++'
"Operand Type" = 'function'
Feature = 'return'
Subfeature = 'normal value'
Importance = ''
"Implementation Type" = ''
Syntax = 'T fn(..) {.. return val;}'
Description = 'Callee gets a copy of the object returned.'

[[data]]
Language = 'C++'
"Operand Type" = 'function'
Feature = 'return'
Subfeature = 'constant reference'
Importance = ''
"Implementation Type" = ''
Syntax = 'T& fn(..) {.. return val; .. return *ptr;}'
Description = '''Can never return a null reference (there isn't any such thing.)'''

[[data]]
Language = 'C++'
"Operand Type" = 'function'
Feature = 'return'
Subfeature = 'constant reference to constant'
Importance = ''
"Implementation Type" = ''
Syntax = 'const T& fn(..) {.. return val; .. return *ptr;}'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'function'
Feature = 'return'
Subfeature = '''
pointer
constant reference'''
Importance = ''
"Implementation Type" = 'caveat'
Syntax = ''
Description = 'Do not return a value instantiated in the stack space, which will be destroyed upon return.'

[[data]]
Language = 'C++'
"Operand Type" = 'function'
Feature = 'return multiple values'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = ''
Description = '''
* Use a monad or other collection.
* Or accept pointer arguments where returned values are set.'''

[[data]]
Language = 'C++'
"Operand Type" = 'function'
Feature = 'entry point'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = 'void main(char ** argv, int argc)'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'function'
Feature = 'invocation'
Subfeature = 'returning value'
Importance = ''
"Implementation Type" = ''
Syntax = 'T var = fn(); //  make copy'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'function'
Feature = 'invocation'
Subfeature = '''
returning 
constant reference'''
Importance = ''
"Implementation Type" = ''
Syntax = '''
T& var = fn(..);
T var = fn(..); //  make copy'''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'function'
Feature = 'invocation'
Subfeature = 'returning constant reference to constant'
Importance = ''
"Implementation Type" = ''
Syntax = '''
const T& var = fn(..);
T var = fn(..); //  make copy
T& var = fn(...) // does not work.'''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'function'
Feature = 'parameter'
Subfeature = 'immutable'
Importance = ''
"Implementation Type" = ''
Syntax = '''
const typ name;
'''
Description = 'value not necessarily known at compile time'

[[data]]
Language = 'C++'
"Operand Type" = 'function'
Feature = 'parameter'
Subfeature = 'pointer'
Importance = ''
"Implementation Type" = ''
Syntax = 'typ * var'
Description = 'pointer passed during invocation.'

[[data]]
Language = 'C++'
"Operand Type" = 'function'
Feature = 'parameter'
Subfeature = 'reference / const pointer '
Importance = ''
"Implementation Type" = ''
Syntax = 'typ &var'
Description = 'variable, not pointer passed during invocation'

[[data]]
Language = 'C++'
"Operand Type" = 'function'
Feature = 'parameter'
Subfeature = 'pass by value'
Importance = ''
"Implementation Type" = ''
Syntax = 'T var'
Description = '''
Copy constructor used.  
Default and user defined conversions happen.'''

[[data]]
Language = 'C++'
"Operand Type" = 'functor'
Feature = 'initialize'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = '''
std::function<ReturnType(Args...)> foo;
void Nop() {}
std::function<void()> a = Nop;                // Function pointers are functors.
std::function<int(int)> square = [](int x) { return x*x; }; '''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'format'
Feature = ''
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = 'clang-format -i fileName'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'statement'
Feature = 'codeblock'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = '{statements}'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'statement'
Feature = 'generic'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = 'statement;'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'statement'
Feature = 'comment'
Subfeature = 'single line'
Importance = ''
"Implementation Type" = ''
Syntax = '\\ comment'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'statement'
Feature = 'comment'
Subfeature = 'multiple line'
Importance = ''
"Implementation Type" = ''
Syntax = '\* comments*\'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'statement'
Feature = 'namespace'
Subfeature = 'definition'
Importance = ''
"Implementation Type" = ''
Syntax = 'namespace NS {}'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'statement'
Feature = 'namespace'
Subfeature = 'alias'
Importance = ''
"Implementation Type" = ''
Syntax = '''
namespace ublas = boost::numeric::ublas;
'''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'statement'
Feature = 'namespace'
Subfeature = 'reference'
Importance = ''
"Implementation Type" = ''
Syntax = 'NS::literal'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'statement'
Feature = 'namespace'
Subfeature = 'reference to global namespace'
Importance = ''
"Implementation Type" = ''
Syntax = '::subNS/literal'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'statement'
Feature = 'namespace'
Subfeature = 'private names'
Importance = ''
"Implementation Type" = ''
Syntax = 'namespace xyz{namespase{int i;}}'
Description = 'ensures that i is not visible in other files where xyz is used'

[[data]]
Language = 'C++'
"Operand Type" = 'statement'
Feature = 'namespace'
Subfeature = 'use'
Importance = ''
"Implementation Type" = ''
Syntax = 'using xyz::cls;'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'statement'
Feature = 'namespace'
Subfeature = 'use'
Importance = ''
"Implementation Type" = ''
Syntax = '''
using namespace mapreduce_testing;
'''
Description = 'Deprecated. Pollutes namespace.'

[[data]]
Language = 'C++'
"Operand Type" = 'statement'
Feature = 'branching'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = 'if(condition) codeblock [else codeblock]'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'statement'
Feature = 'branching'
Subfeature = 'multi'
Importance = ''
"Implementation Type" = ''
Syntax = 'switch(variableName) case value: codeblock (with break;) default: (with break;)'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'statement'
Feature = 'exception handling'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = '''
 try
        {
                throw 20;
  }
catch (int param) { cout << "int exception"; }
catch (char param) { cout << "char exception";}
catch (...) { cout << "default exception"; }

'''
Description = '''
#include <exception>' has useful methods for printing common exceptions.
Not allowed in Google C++. (statusor or function accepts pointer, return success boolean)'''

[[data]]
Language = 'C++'
"Operand Type" = 'time'
Feature = ''
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = '''
#include <ctime>
time_t t = time(0);   // get time now in sec since epoch
string srtTime = ctime(&t);'''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'time'
Feature = ''
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = '''
#include <iostream>
#include <string>
#include <stdio.h>
#include <time.h>

// Get current date/time, format is YYYY-MM-DD.HH:mm:ss
    time_t     now = time(0);
    struct tm  tstruct;
    char       buf[80];
    tstruct = *localtime(&now);
    strftime(buf, sizeof(buf), "%Y-%m-%d.%X", &tstruct);
'''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'math'
Feature = ''
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = '''
#include <math.h>       /* pow */
printf ("7 ^ 3 = %f\n", pow (7.0, 3.0) );'''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = ''
Feature = ''
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = ''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = ''
Feature = ''
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = ''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'source file'
Feature = 'declaration header'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = 'Class and method declarations in xyz.h'
Description = '''
Linked to an function implementations in .cpp file later.
Avoids error from multiple C++ files defining the same class/ function.'''

[[data]]
Language = 'C++'
"Operand Type" = 'source file'
Feature = 'declaration header'
Subfeature = ''
Importance = ''
"Implementation Type" = 'Caveat'
Syntax = ''
Description = 'Dont define a funciton in the header (unless it is a template function) - this can lead to "multiple definition of function" error if the same header gets included twice in different files.'

[[data]]
Language = 'C++'
"Operand Type" = 'source file'
Feature = 'definition file'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = 'Definitions in .cc file.'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'source file'
Feature = 'include'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = '#include "fileName"'
Description = '''
To ensure that same header is not included twice in the files sent to the linker, must use:
#ifdef XYZ_H_
# define XYZ_H_
...
#endif // XYZ_H_'''

[[data]]
Language = 'C++'
"Operand Type" = 'source file'
Feature = 'include'
Subfeature = 'at most once'
Importance = ''
"Implementation Type" = ''
Syntax = '#import "fileName"'
Description = 'Include header at most once.'

[[data]]
Language = 'C++'
"Operand Type" = 'source file'
Feature = 'include'
Subfeature = 'Avoidance'
Importance = ''
"Implementation Type" = ''
Syntax = ''
Description = '''
Prefer forward declaration of functions in order to 
avoid building dependencies while building the current file.'''

[[data]]
Language = 'C++'
"Operand Type" = 'regular expression'
Feature = 'partial match'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = '''
#include "util/regexp/re2/re2.h"
RE2 re("(\\d{3}-\\d{3}-\\d{4})");
for(Doc::iterator d = docs.begin(); d != docs.end(); ++d) {
  StringPiece sp;
  if (RE2::PartialMatch(d->text(), re, &sp))
    LOG(INFO) << "Match: " << sp;
}'''
Description = 'RE2 cheatsheet available online.'

[[data]]
Language = 'C++'
"Operand Type" = 'regular expression RE2'
Feature = 'full match'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = '''
#include "util/regexp/re2/re2.h"
RE2 re("(\\d{3}-\\d{3}-\\d{4})");
return RE2::FullMatch(s, *regex);'''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'regular expression RE2'
Feature = 'static'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = '''
static LazyRE2 regex = { R"(\d\d\d\d-\d\d-\d\d)" };
bool LooksLikeISODate(StringPiece s) {
  return RE2::FullMatch(s, *regex);
}'''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'regular expression RE2'
Feature = 'capture text'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = '''
static LazyRE2 regex = { R"((\d\d\d\d)-(\d\d)-(\d\d))" };
bool ExtractISODate(StringPiece s, string* year, string* month,
                    string* day) {
  return RE2::FullMatch(s, *regex, year, month, day);
}'''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'IO'
Feature = ''
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = '''
#include <iostream>
using namespace std;
cout << literalOrVar << endl;
'''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'IO'
Feature = 'printf'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = '%[flags][width][.precision][length]specifier '
Description = 'width: min characters to print (with padding).'

[[data]]
Language = 'C++'
"Operand Type" = 'IO'
Feature = 'printf'
Subfeature = 'specifier'
Importance = ''
"Implementation Type" = ''
Syntax = '''
[l|ll - long long] d|i u o x X
f F e E g G (shortest of F, G)
a A (hex float)
c s
p (ptr)'''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'IO'
Feature = 'printf'
Subfeature = 'flags'
Importance = ''
"Implementation Type" = ''
Syntax = '''
- justify + force sign
0 padding
# with o x X: print 0 0x 0X for non 0'''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'IO'
Feature = 'input'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = 'scanf("%d", &[?]xInt)'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'IO'
Feature = 'ifstream'
Subfeature = 'setup'
Importance = ''
"Implementation Type" = ''
Syntax = '''
#include <iostream>
#include <fstream>
ifstream streamx(pathStr);'''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'IO'
Feature = 'ifstream'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = '''
streamx>> var2;
'''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'debugging'
Feature = 'segmentation fault'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = 'SIGSEGV (@(nil))'
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'debugging'
Feature = 'Inheritence: linking'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = '''
vtable ... 
'''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'debugging'
Feature = 'segmentation fault'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = ''
Description = '''
Causes: Double deletion.
Trying to delete a pointer one does not own.
'''

[[data]]
Language = 'C++'
"Operand Type" = 'char[]'
Feature = 'instantiation'
Subfeature = 'literal'
Importance = ''
"Implementation Type" = ''
Syntax = '''
"asdf"
someStr.c_str()'''
Description = 'Array terminated by \0'

[[data]]
Language = 'C++'
"Operand Type" = 'types'
Feature = 'cord'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = ''
Description = '''
String stored as a tree of strings.
Easier to find memory for storing big strings.
Slower random access.
Copy-on-write - so copying faster.'''

[[data]]
Language = 'C++'
"Operand Type" = 'types'
Feature = '[unsigned|long] int'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = ''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'types'
Feature = 'char'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = ''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'types'
Feature = '[unsigned] short'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = ''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'types'
Feature = '''
[unsigned|long] [int]
long long [int] int64'''
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = ''
Description = ''

[[data]]
Language = 'C++'
"Operand Type" = 'types'
Feature = '[unsigned|long] [double| float]'
Subfeature = ''
Importance = ''
"Implementation Type" = ''
Syntax = ''
Description = ''
