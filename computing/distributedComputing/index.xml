<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>&#43;Distributed computing on Vishvas&#39;s notes</title>
    <link>file:///storage/emulated/0/notesData/notes/computing/distributedComputing/</link>
    <description>Recent content in &#43;Distributed computing on Vishvas&#39;s notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="file:///storage/emulated/0/notesData/notes/computing/distributedComputing/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Designing</title>
      <link>file:///storage/emulated/0/notesData/notes/computing/distributedComputing/designing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>file:///storage/emulated/0/notesData/notes/computing/distributedComputing/designing/</guid>
      <description>By designing action systems By specifying the safety and progress properties the distributed computation should have, you can then design a compliant action system. Then you can refine this in various ways to get different looking implementations.
Coordinating processes There is always an initiator process.
General signalling constructs See programming ref. Callback, polling.
Synchronization Blocking Process A may be listening in the channel, and may be blocked until it receives a message.</description>
    </item>
    
    <item>
      <title>Reasoning</title>
      <link>file:///storage/emulated/0/notesData/notes/computing/distributedComputing/reasoning/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>file:///storage/emulated/0/notesData/notes/computing/distributedComputing/reasoning/</guid>
      <description>Common assumptions A channel eventually (maybe at \(t=\infty\)) delivers all packets without corruption or dropping, in the correct order.
Processes can run at arbitrary, non 0 speed.
Don&amp;rsquo;t care about efficiency, focus on safety and progress.
Assume you have infinite buffers.
Synchronized communication Sometimes, this is needed. Max time to deliver a message is some t.
Proving algorithm efficacy Axiomatize the system, and use pure logic.
Usually 2 stages: safety property: you won&amp;rsquo;t fall into a wrong state; and progress property.</description>
    </item>
    
  </channel>
</rss>