<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>&#43;Complexity classes on Vishvas&#39;s notes</title>
    <link>file:///storage/emulated/0/notesData/notes/computing/computationalComplexity/complexity_classes/</link>
    <description>Recent content in &#43;Complexity classes on Vishvas&#39;s notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="file:///storage/emulated/0/notesData/notes/computing/computationalComplexity/complexity_classes/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>01 Computability and efficiency of problems</title>
      <link>file:///storage/emulated/0/notesData/notes/computing/computationalComplexity/complexity_classes/01_Computability_and_efficiency_of_problems/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>file:///storage/emulated/0/notesData/notes/computing/computationalComplexity/complexity_classes/01_Computability_and_efficiency_of_problems/</guid>
      <description>Uncomputability by TM Tabulate all TM strings vs all inputs; mark output (0, 1 or *); \textbf{diagonalize} (reverse output in diagonal) to get function UC no TM can solve. \textbf{Halting problem}: Uncomputable, else UC computable; Even model checking cannot predict halting of the twin primes (p, p+2) problem.
Decidability by TM TM decides &amp;lsquo;recursive languages&amp;rsquo;. Given query \(x \in L?\), TM gives coorect answer eventually.
Acceptance by TM/ Recursive enumerability Given query \(x \in L?</description>
    </item>
    
    <item>
      <title>02 P and NP</title>
      <link>file:///storage/emulated/0/notesData/notes/computing/computationalComplexity/complexity_classes/02_P_and_NP/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>file:///storage/emulated/0/notesData/notes/computing/computationalComplexity/complexity_classes/02_P_and_NP/</guid>
      <description>P P=coP. P completeness. CIRCUIT VALUE is P complete: In P by Spira and \(DSPACE(log^{k} n) \subseteq P\); . (Find out more.)
Non determinism NP Evaluatable by a non-deterministic turning machine. All computation paths end in polytime.
Acceptance of x If \(x \in L\), there is at least 1 path which leads to acceptance of x. Else, all paths lead to rejection of x. Thus, assymetry in Acceptance/ Rejection criteria.</description>
    </item>
    
    <item>
      <title>03 Other classes</title>
      <link>file:///storage/emulated/0/notesData/notes/computing/computationalComplexity/complexity_classes/03_Other_classes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>file:///storage/emulated/0/notesData/notes/computing/computationalComplexity/complexity_classes/03_Other_classes/</guid>
      <description>Space-classes \(NTIME(f(n)) \subseteq DSPACE(f(n))\).\
L, NL, polylog space, \(PSPACE = NSPACE\). \(L \subseteq NL \subseteq P \subseteq NP \subseteq PSPACE\): One of these is \(\subset\): from space hierarchy theorem.
\textbf{Reachability method} on configuration graph: \
\(NSPACE(f(n)) \subseteq DTIME(2^{f(n)})\).
Directed reachability in \(DSPACE(log^{2} n)\) (Savitch) \chk. So, by reachability method: \(NSPACE(f(n)) = DSPACE((f(n))^{2})\). Reachability is NL complete. \why
Immerman-Szelepcsenyi: \(Unreachability \in NL\).\
So, coNSPACE(f(n)) = NSPACE(f(n)).
Boolean circuits See Boolean fn ref.</description>
    </item>
    
    <item>
      <title>04 Other notions of complexity</title>
      <link>file:///storage/emulated/0/notesData/notes/computing/computationalComplexity/complexity_classes/04_Other_notions_of_complexity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>file:///storage/emulated/0/notesData/notes/computing/computationalComplexity/complexity_classes/04_Other_notions_of_complexity/</guid>
      <description>Communication complexity See Information and coding theory ref.
Komogrov complexity Of a computational object: Resourses required to specify it. Eg: If P is a program which outputs a string x, then P is a description of x. The length of the description is just the length of P as a character string.
Smoothed complexity \tbc</description>
    </item>
    
    <item>
      <title>05 Other topics</title>
      <link>file:///storage/emulated/0/notesData/notes/computing/computationalComplexity/complexity_classes/05_Other_topics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>file:///storage/emulated/0/notesData/notes/computing/computationalComplexity/complexity_classes/05_Other_topics/</guid>
      <description>Explore further Interactive proofs. Transperent proofs: a small error shows up every where - make combinations of atomic results.
Lower bounds Crossing sequence: an important trick. \tbc Adverserial technique: Let adversary make an alg, you make an input to screw it up. \tbc Use information theory. Reduce to other hard problems. Construct input for which minimum processing is required.
\(P \neq NP\) proof is hard: natural proofs (satisfy constructivity and largeness) won&amp;rsquo;t work: else you&amp;rsquo;ll end up with an alg =f(proof) to solve NP prob in Poly time.</description>
    </item>
    
  </channel>
</rss>